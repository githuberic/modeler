# byte为什么要与上0xff？

```java
public static void main(String[] args) {
    byte[] a = new byte[10];
    a[0] = -127;
    System.out.println(a[0]);
    // 打印a[0]&0xff后的值，本来我想结果应该都是-127.
    int c = a[0] & 0xff;
    System.out.println(c);
}
```

先打印a[0],在打印a[0]&0xff后的值，本来想结果应该都是-127.
但是结果真的是出人意料啊！
-127
129
到底是为什么呢？&0xff反而不对了。

了解到计算机内的存储都是利用二进制的补码进行存储的。

原码反码补码这三个概念
- 对于正数（00000001） 原码来说，首位表示符号位，反码 补码都是本身
- 对于负数（10000001） 原码来说，反码是对原码除了符号位之外作取反运算即（111111110），补码是对反码作+1运算即（111111111）

当将-127赋值给a[0]时候，a[0]作为一个byte类型，其计算机存储的补码是10000001（8位）。

计算过程：
127的二级制(原码) 0111 1111
-127的原码：1111 1111，-127的的反码=1000 0000 ，-127的补码=1000 0001；

将a[0] 作为int类型向控制台输出的时候，jvm作了一个补位的处理，因为int类型是32位所以补位后的补码就是11111111 11111111 11111111 10000001（32位，按符号位进行补位），这个32位二进制补码表示的也是-127.

<b>为什么byte类型的数字要&0xff再赋值给int类型，<font color="#ff0000">其本质原因就是想保持二进制补码的一致性。</font></b>

当byte要转化为int的时候，高的24位必然会补1，这样，其二进制补码其实已经不一致了，&0xff可以将高的24位置为0，低8位保持原样。这样做的目的就是为了保证二进制数据的一致性。

当然拉，保证了二进制数据性的同时，如果二进制被当作byte和int来解读，其10进制的值必然是不同的，因为符号位位置已经发生了变化。

实例2中，int c = a[0]&0xff;  
a[0]&0xff=1111111111111111111111111 10000001&11111111=000000000000000000000000 10000001 ，这个值算一下就是129，

有人问为什么上面的式子中a[0]不是8位而是32位，因为当系统检测到byte可能会转化成int或者说byte与int类型进行运算的时候，就会将byte的内存空间高位补1（也就是按符号位补位）扩充到32位，再参与运算。

上面的0xff其实是int类型的字面量值，所以可以说byte与int进行运算。
